{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Enrichment Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "input_file = \"/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/samples_features_means_updated.csv\"\n",
    "df = pd.read_csv(input_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Standardization "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.cluster import KMeans\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Select numeric columns for clustering, excluding metadata\n",
    "numeric_columns = [col for col in df.columns if col not in ['label', 'batch', 'group', 'filename', 'gene']]\n",
    "\n",
    "# Extract features for clustering\n",
    "X = df[numeric_columns].values\n",
    "\n",
    "# Standardize the features (zero mean, unit variance)\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "scaler = StandardScaler()\n",
    "X_scaled = scaler.fit_transform(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Clustering K-Means"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.cluster import KMeans\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Perform the elbow method to determine the optimal number of clusters\n",
    "wcss = []\n",
    "max_clusters = 15  # Adjust the range of clusters to test\n",
    "for i in range(1, max_clusters + 1):\n",
    "    kmeans = KMeans(n_clusters=i, random_state=42)\n",
    "    kmeans.fit(X_scaled)\n",
    "    wcss.append(kmeans.inertia_)\n",
    "\n",
    "# Plot the elbow curve\n",
    "plt.figure(figsize=(8, 6))\n",
    "plt.plot(range(1, max_clusters + 1), wcss, marker='o', linestyle='-', color='#1f77b4')\n",
    "plt.title('Elbow Method for Optimal Number of Clusters')\n",
    "plt.xlabel('Number of Clusters')\n",
    "plt.ylabel('WCSS')\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Choose the optimal number of clusters based on the elbow plot (manual inspection)\n",
    "n_clusters = 7  # Replace with the number you determine from the plot\n",
    "\n",
    "# Perform K-means clustering with the chosen number of clusters\n",
    "kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n",
    "cluster_labels = kmeans.fit_predict(X_scaled)\n",
    "\n",
    "# Add cluster labels to the original DataFrame\n",
    "df['k-means'] = cluster_labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Retrieve and print gene names for each cluster\n",
    "unique_clusters = df['k-means'].unique()\n",
    "print(\"GENE NAMES PER CLUSTER:\")\n",
    "for cluster in unique_clusters:\n",
    "    cluster_mask = df['k-means'] == cluster\n",
    "    cluster_genes = df[cluster_mask]['gene'].dropna().unique()\n",
    "    print(f\"Cluster {cluster}: {', '.join(cluster_genes) if len(cluster_genes) > 0 else 'No genes found'}\")\n",
    "\n",
    "# Save gene names per cluster to a CSV file\n",
    "cluster_gene_df = df[['k-means', 'gene']].dropna().groupby('k-means')['gene'].apply(lambda x: ', '.join(x.unique())).reset_index()\n",
    "output_file = '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/kmeans_cluster_genes.csv'\n",
    "cluster_gene_df.to_csv(output_file, index=False)\n",
    "print(f\"\\nCluster gene assignments saved to {output_file}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Gaussian Mixture model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.mixture import GaussianMixture\n",
    "\n",
    "n_components_range = range(1, 12)  # Adjust range as needed\n",
    "bic = []\n",
    "for n in n_components_range:\n",
    "    gmm = GaussianMixture(n_components=n, random_state=42)\n",
    "    gmm.fit(X_scaled)\n",
    "    bic.append(gmm.bic(X_scaled))\n",
    "\n",
    "# Plot BIC to choose number of components\n",
    "plt.plot(n_components_range, bic, marker='o')\n",
    "plt.xlabel('Number of Components')\n",
    "plt.ylabel('BIC Score')\n",
    "plt.title('BIC for Different Number of Components')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Choose the optimal number of components based on the BIC plot (manual inspection)\n",
    "n_components = 7  # Replace with the number you determine from the plot\n",
    "\n",
    "# Perform GMM clustering with the chosen number of components\n",
    "gmm = GaussianMixture(n_components=n_components, random_state=42)\n",
    "cluster_labels = gmm.fit_predict(X_scaled)\n",
    "\n",
    "# Add cluster labels to the original DataFrame\n",
    "df['gaussian'] = cluster_labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Retrieve and print gene names for each cluster\n",
    "unique_clusters = df.gaussian.unique()\n",
    "print(\"GENE NAMES PER CLUSTER:\")\n",
    "for cluster in unique_clusters:\n",
    "    cluster_mask = df['gaussian'] == cluster\n",
    "    cluster_genes = df[cluster_mask]['gene'].dropna().unique()\n",
    "    print(f\"Cluster {cluster}: {', '.join(cluster_genes) if len(cluster_genes) > 0 else 'No genes found'}\")\n",
    "\n",
    "# Save gene names per cluster to a CSV file\n",
    "cluster_gene_df = df[['gaussian', 'gene']].dropna().groupby('gaussian')['gene'].apply(lambda x: ', '.join(x.unique())).reset_index()\n",
    "output_file = '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/gmm_cluster_genes.csv'\n",
    "cluster_gene_df.to_csv(output_file, index=False)\n",
    "print(f\"\\nCluster gene assignments saved to {output_file}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### HDBSCAN"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import hdbscan\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "# Perform HDBSCAN clustering\n",
    "hdb = hdbscan.HDBSCAN(min_cluster_size=5, min_samples=5, cluster_selection_method='eom')\n",
    "cluster_labels = hdb.fit_predict(X_scaled)\n",
    "\n",
    "# Add cluster labels to the original DataFrame\n",
    "df['hdbscan'] = cluster_labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "unique_clusters = df.hdbscan.unique()\n",
    "\n",
    "# Retrieve and print gene names for each cluster\n",
    "print(\"\\nGene names per cluster:\")\n",
    "for cluster in sorted(unique_clusters):\n",
    "    cluster_mask = df['hdbscan'] == cluster\n",
    "    cluster_genes = df[cluster_mask]['gene'].dropna().unique()\n",
    "    print(f\"Cluster {cluster}: {', '.join(cluster_genes) if len(cluster_genes) > 0 else 'No genes found'}\")\n",
    "\n",
    "# Save gene names per cluster to a CSV file\n",
    "cluster_gene_df = df[['hdbscan', 'gene']].dropna().groupby('hdbscan')['gene'].apply(lambda x: ', '.join(x.unique())).reset_index()\n",
    "output_file = '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/hdbscan_cluster_genes.csv'\n",
    "cluster_gene_df.to_csv(output_file, index=False)\n",
    "print(f\"Cluster gene assignments saved to {output_file}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Perform PCA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Select numeric columns for PCA, excluding metadata\n",
    "numeric_columns = [col for col in df.columns if col not in ['label', 'batch', 'group', 'filename', 'gene', 'k-means', 'gaussian', 'hdbscan']]\n",
    "\n",
    "# Extract features for PCA\n",
    "X = df[numeric_columns].values\n",
    "\n",
    "# Standardize the features (zero mean, unit variance)\n",
    "scaler = StandardScaler()\n",
    "X_scaled = scaler.fit_transform(X)\n",
    "\n",
    "# Apply PCA to reduce to 2 components\n",
    "pca = PCA(n_components=2)\n",
    "X_pca = pca.fit_transform(X_scaled)\n",
    "\n",
    "# Create a DataFrame with PCA results\n",
    "pca_df = pd.DataFrame(X_pca, columns=['PC1', 'PC2'])\n",
    "pca_df['label'] = df['label'].values\n",
    "pca_df['batch'] = df['batch'].values\n",
    "pca_df['group'] = df['group'].values\n",
    "pca_df['gene'] = df['gene'].values\n",
    "pca_df['filename'] = df['filename'].values\n",
    "pca_df['k-means'] = df['k-means'].values\n",
    "pca_df['gaussian'] = df['gaussian'].values\n",
    "pca_df['hdbscan'] = df['hdbscan'].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_clusters_pca(pca_df, cluster_col, pca, output_path, figsize=(10, 8), alpha=0.6, point_size=50):\n",
    "    \"\"\"\n",
    "    Plot clusters on PCA results with gene annotations for mutants.\n",
    "    \n",
    "    Parameters:\n",
    "    - pca_df: DataFrame with columns 'PC1', 'PC2', 'cluster', 'label', and 'gene'\n",
    "    - pca: PCA object from sklearn.decomposition.PCA\n",
    "    - output_path: str, path to save the plot\n",
    "    - figsize: tuple, figure size (width, height)\n",
    "    - alpha: float, transparency of scatter points\n",
    "    - point_size: int, size of scatter points\n",
    "    \"\"\"\n",
    "    plt.figure(figsize=figsize)\n",
    "    unique_clusters = sorted(pca_df[cluster_col].unique())\n",
    "    colors = plt.colormaps.get_cmap('tab10')\n",
    "\n",
    "    # Plot each cluster\n",
    "    for cluster in unique_clusters:\n",
    "        mask = pca_df[cluster_col] == cluster\n",
    "        plt.scatter(\n",
    "            pca_df[mask]['PC1'],\n",
    "            pca_df[mask]['PC2'],\n",
    "            label=f'Cluster {cluster}',\n",
    "            color=colors(cluster),\n",
    "            alpha=alpha,\n",
    "            s=point_size\n",
    "        )\n",
    "\n",
    "    # Add gene annotations for mutants (label == 1)\n",
    "    mutant_mask = pca_df['label'] == 1\n",
    "    for idx, row in pca_df[mutant_mask].iterrows():\n",
    "        if pd.notna(row['gene']):\n",
    "            plt.annotate(\n",
    "                row['gene'],\n",
    "                (row['PC1'], row['PC2']),\n",
    "                xytext=(7, 7),\n",
    "                textcoords='offset points',\n",
    "                fontsize=7,\n",
    "                color='black',\n",
    "                bbox=dict(facecolor='white', alpha=0.6, edgecolor='gray', boxstyle='round,pad=0.3')\n",
    "            )\n",
    "\n",
    "    # Add plot details\n",
    "    plt.title(f'{cluster_col} Clustering on PCA of Sample Feature Means')\n",
    "    plt.xlabel(f'Principal Component 1 ({pca.explained_variance_ratio_[0]:.2%} variance)')\n",
    "    plt.ylabel(f'Principal Component 2 ({pca.explained_variance_ratio_[1]:.2%} variance)')\n",
    "    plt.legend(title='Cluster')\n",
    "    plt.grid(True)\n",
    "\n",
    "    # Save the plot\n",
    "    plt.savefig(output_path, dpi=300, bbox_inches='tight')\n",
    "    plt.close()  # Close the figure to prevent display in non-interactive environments\n",
    "    \n",
    "    print(f\"Clustering plot saved to {output_path}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_clusters_pca(pca_df, 'k-means', pca, '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/kmeans_pca_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_clusters_pca(pca_df,'hdbscan', pca, '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/hdbscan_pca_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_clusters_pca(pca_df,'gaussian',  pca, '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/gaussian_pca_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_clusters_pca(pca_df,'label',  pca, '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/label_pca_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## t-SNE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.manifold import TSNE\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Select numeric columns for t-SNE, excluding metadata\n",
    "numeric_columns = [col for col in df.columns if col not in ['label', 'batch', 'group', 'filename', 'gene', 'k-means', 'gaussian', 'hdbscan']]\n",
    "\n",
    "# Extract features for t-SNE\n",
    "X = df[numeric_columns].values\n",
    "\n",
    "# Standardize the features (zero mean, unit variance)\n",
    "scaler = StandardScaler()\n",
    "X_scaled = scaler.fit_transform(X)\n",
    "\n",
    "# Apply t-SNE to reduce to 2 components\n",
    "tsne = TSNE(n_components=2, random_state=42)\n",
    "X_tsne = tsne.fit_transform(X_scaled)\n",
    "\n",
    "# Create a DataFrame with t-SNE results\n",
    "tsne_df = pd.DataFrame(X_tsne, columns=['TSNE1', 'TSNE2'])\n",
    "tsne_df['label'] = df['label'].values\n",
    "tsne_df['batch'] = df['batch'].values\n",
    "tsne_df['group'] = df['group'].values\n",
    "tsne_df['gene'] = df['gene'].values\n",
    "tsne_df['filename'] = df['filename'].values\n",
    "tsne_df['k-means'] = df['k-means'].values\n",
    "tsne_df['gaussian'] = df['gaussian'].values\n",
    "tsne_df['hdbscan'] = df['hdbscan'].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_clusters_tsne(tsne_df, cluster_col, output_path, figsize=(10, 8), alpha=0.6, point_size=50):\n",
    "    \"\"\"\n",
    "    Plot clusters on t-SNE results with gene annotations for mutants.\n",
    "    \n",
    "    Parameters:\n",
    "    - tsne_df: DataFrame with columns 'TSNE1', 'TSNE2', 'cluster', 'label', and 'gene'\n",
    "    - cluster_col: str, column name containing cluster labels\n",
    "    - output_path: str, path to save the plot\n",
    "    - figsize: tuple, figure size (width, height)\n",
    "    - alpha: float, transparency of scatter points\n",
    "    - point_size: int, size of scatter points\n",
    "    \"\"\"\n",
    "    plt.figure(figsize=figsize)\n",
    "    unique_clusters = sorted(tsne_df[cluster_col].unique())\n",
    "    colors = plt.colormaps.get_cmap('tab10')\n",
    "\n",
    "    # Define legend labels, handling HDBSCAN noise points\n",
    "    label_names = {cluster: f'Cluster {cluster}' for cluster in unique_clusters}\n",
    "    if -1 in unique_clusters:\n",
    "        label_names[-1] = 'Noise'\n",
    "\n",
    "    # Plot each cluster\n",
    "    for cluster in unique_clusters:\n",
    "        mask = tsne_df[cluster_col] == cluster\n",
    "        plt.scatter(\n",
    "            tsne_df[mask]['TSNE1'],\n",
    "            tsne_df[mask]['TSNE2'],\n",
    "            label=label_names.get(cluster, f'Cluster {cluster}'),\n",
    "            color=colors((cluster + 1) / len(unique_clusters) if cluster != -1 else 0.0),\n",
    "            alpha=alpha,\n",
    "            s=point_size\n",
    "        )\n",
    "\n",
    "    # Add gene annotations for mutants (label == 1)\n",
    "    mutant_mask = tsne_df['label'] == 1\n",
    "    for idx, row in tsne_df[mutant_mask].iterrows():\n",
    "        if pd.notna(row['gene']):\n",
    "            plt.annotate(\n",
    "                row['gene'],\n",
    "                (row['TSNE1'], row['TSNE2']),\n",
    "                xytext=(7, 7),\n",
    "                textcoords='offset points',\n",
    "                fontsize=7,\n",
    "                color='black',\n",
    "                bbox=dict(facecolor='white', alpha=0.6, edgecolor='gray', boxstyle='round,pad=0.3')\n",
    "            )\n",
    "\n",
    "    # Add plot details\n",
    "    plt.title(f'{cluster_col} Clustering on t-SNE of Sample Feature Means')\n",
    "    plt.xlabel('t-SNE Dimension 1')\n",
    "    plt.ylabel('t-SNE Dimension 2')\n",
    "    plt.legend(title='Cluster')\n",
    "    plt.grid(True)\n",
    "\n",
    "    # Save the plot\n",
    "    plt.savefig(output_path, dpi=300, bbox_inches='tight')\n",
    "    plt.close()  # Close the figure to prevent display in non-interactive environments\n",
    "    \n",
    "    print(f\"t-SNE clustering plot saved to {output_path}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Plot t-SNE results for K-Means, HDBSCAN, Gaussian, and Label\n",
    "plot_clusters_tsne(tsne_df, 'k-means', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/kmeans_tsne_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)\n",
    "plot_clusters_tsne(tsne_df, 'hdbscan', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/hdbscan_tsne_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)\n",
    "plot_clusters_tsne(tsne_df, 'gaussian', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/gaussian_tsne_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)\n",
    "plot_clusters_tsne(tsne_df, 'label', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/label_tsne_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### UMAP"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import umap\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Select numeric columns for UMAP, excluding metadata\n",
    "numeric_columns = [col for col in df.columns if col not in ['label', 'batch', 'group', 'filename', 'gene', 'k-means', 'gaussian', 'hdbscan']]\n",
    "\n",
    "# Extract features for UMAP\n",
    "X = df[numeric_columns].values\n",
    "\n",
    "# Standardize the features (zero mean, unit variance)\n",
    "scaler = StandardScaler()\n",
    "X_scaled = scaler.fit_transform(X)\n",
    "\n",
    "# Apply UMAP to reduce to 2 components\n",
    "reducer = umap.UMAP(n_components=2, random_state=42)\n",
    "X_umap = reducer.fit_transform(X_scaled)\n",
    "\n",
    "# Create a DataFrame with UMAP results\n",
    "umap_df = pd.DataFrame(X_umap, columns=['UMAP1', 'UMAP2'])\n",
    "umap_df['label'] = df['label'].values\n",
    "umap_df['batch'] = df['batch'].values\n",
    "umap_df['group'] = df['group'].values\n",
    "umap_df['gene'] = df['gene'].values\n",
    "umap_df['filename'] = df['filename'].values\n",
    "umap_df['k-means'] = df['k-means'].values\n",
    "umap_df['gaussian'] = df['gaussian'].values\n",
    "umap_df['hdbscan'] = df['hdbscan'].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_clusters_umap(umap_df, cluster_col, output_path, figsize=(10, 8), alpha=0.6, point_size=50):\n",
    "    \"\"\"\n",
    "    Plot clusters on UMAP results with gene annotations for mutants.\n",
    "    \n",
    "    Parameters:\n",
    "    - umap_df: DataFrame with columns 'UMAP1', 'UMAP2', 'cluster', 'label', and 'gene'\n",
    "    - cluster_col: str, column name containing cluster labels\n",
    "    - output_path: str, path to save the plot\n",
    "    - figsize: tuple, figure size (width, height)\n",
    "    - alpha: float, transparency of scatter points\n",
    "    - point_size: int, size of scatter points\n",
    "    \"\"\"\n",
    "    plt.figure(figsize=figsize)\n",
    "    unique_clusters = sorted(umap_df[cluster_col].unique())\n",
    "    colors = plt.colormaps.get_cmap('tab10')\n",
    "\n",
    "    # Define legend labels, handling HDBSCAN noise points\n",
    "    label_names = {cluster: f'Cluster {cluster}' for cluster in unique_clusters}\n",
    "    if -1 in unique_clusters:\n",
    "        label_names[-1] = 'Noise'\n",
    "\n",
    "    # Plot each cluster\n",
    "    for cluster in unique_clusters:\n",
    "        mask = umap_df[cluster_col] == cluster\n",
    "        plt.scatter(\n",
    "            umap_df[mask]['UMAP1'],\n",
    "            umap_df[mask]['UMAP2'],\n",
    "            label=label_names.get(cluster, f'Cluster {cluster}'),\n",
    "            color=colors((cluster + 1) / len(unique_clusters) if cluster != -1 else 0.0),\n",
    "            alpha=alpha,\n",
    "            s=point_size\n",
    "        )\n",
    "\n",
    "    # Add gene annotations for mutants (label == 1)\n",
    "    mutant_mask = umap_df['label'] == 1\n",
    "    for idx, row in umap_df[mutant_mask].iterrows():\n",
    "        if pd.notna(row['gene']):\n",
    "            plt.annotate(\n",
    "                row['gene'],\n",
    "                (row['UMAP1'], row['UMAP2']),\n",
    "                xytext=(7, 7),\n",
    "                textcoords='offset points',\n",
    "                fontsize=7,\n",
    "                color='black',\n",
    "                bbox=dict(facecolor='white', alpha=0.6, edgecolor='gray', boxstyle='round,pad=0.3')\n",
    "            )\n",
    "\n",
    "    # Add plot details\n",
    "    plt.title(f'{cluster_col} Clustering on UMAP of Sample Feature Means')\n",
    "    plt.xlabel('UMAP Dimension 1')\n",
    "    plt.ylabel('UMAP Dimension 2')\n",
    "    plt.legend(title='Cluster')\n",
    "    plt.grid(True)\n",
    "\n",
    "    # Save the plot\n",
    "    plt.savefig(output_path, dpi=300, bbox_inches='tight')\n",
    "    plt.close()  # Close the figure to prevent display in non-interactive environments\n",
    "    \n",
    "    print(f\"UMAP clustering plot saved to {output_path}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Plot UMAP results for K-Means, HDBSCAN, Gaussian, and Label\n",
    "plot_clusters_umap(umap_df, 'k-means', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/kmeans_umap_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)\n",
    "plot_clusters_umap(umap_df, 'hdbscan', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/hdbscan_umap_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)\n",
    "plot_clusters_umap(umap_df, 'gaussian', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/gaussian_umap_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)\n",
    "plot_clusters_umap(umap_df, 'label', '/scratch/leuven/359/vsc35907/big_data_feature_extraction/patches_dirs/label_umap_plot.png', figsize=(10, 8), alpha=0.6, point_size=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "omnipose",
   "language": "python",
   "name": "omnipose"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
